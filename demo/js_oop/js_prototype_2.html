<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>原型链继承-将共享属性迁移到原型中去-提高效率</title>
</head>
<body>
<script>

    //每当用 new Shape() 新建对象时,每个实例都会有一个全新的 name 属性, 并在内存中拥有自己独立的存储空间,为了提高效率,可以针对对象实例中的不可变属性(可重用)和方法,添加到对象的原型中去共享,只围绕原型构建继承关系。
    //临时构造器 ===  new F();
    //即 创建一个空函数 F(),并将其原型设置为父级构造器。然后可以用 new F() 来创建一些不包含父对象属性的对象,同时又可以以从父对象 prototype属性中继承一切

    function Shape() {}
    Shape.prototype.name = 'shape';
    Shape.prototype.toString = function () {
        return this.name;
    };

    function TwoDShape() {}

    var F = function () {};
    F.prototype = Shape.prototype;
    TwoDShape.prototype = new F();
    TwoDShape.prototype.constructor = TwoDShape;

    TwoDShape.prototype.name = '2d shape';


    function Triangle(side, height){
        this.name  = 'Triangle';
        this.side = side;
        this.height = height;

    }
    //通过原型继承
    var F = function () {};
    F.prototype = TwoDShape.prototype;
    Triangle.prototype = new F();
    Triangle.prototype.constructor = Triangle;

    Triangle.prototype.name = 'Triangle';
    Triangle.prototype.getArea = function () {
        return this.side * this.height /2;
    };



    var _tri = new Triangle(2,5);

    //通过 instanceof 操作符,可以验证 _tri 对象同时是上述三个构造器的实例
     console.log(_tri instanceof Shape);
     console.log(_tri instanceof TwoDShape);
     console.log(_tri instanceof Triangle);

</script>
</body>
</html>